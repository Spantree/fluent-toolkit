/**
 * Secrets Manager
 * Handles .env.mcp.secrets file creation and management
 */

import { join } from "@std/path";
import { exists } from "@std/fs";
// Removed unused import

export class SecretsManager {
  /**
   * Get the project secrets file path (.env.mcp.secrets)
   */
  private static getSecretsPath(): string {
    return join(Deno.cwd(), ".env.mcp.secrets");
  }

  /**
   * Get the user secrets file path (~/.ftk/secrets.env)
   */
  private static getUserSecretsPath(): string {
    const home = Deno.env.get("HOME");
    if (!home) {
      throw new Error("HOME environment variable not set");
    }
    return join(home, ".ftk", "secrets.env");
  }

  /**
   * Load secrets from .env file
   */
  static async loadSecrets(scope: "user" | "project" = "project"): Promise<
    Record<string, string>
  > {
    const secretsPath = scope === "user" ? this.getUserSecretsPath() : this.getSecretsPath();

    if (!(await exists(secretsPath))) {
      return {};
    }

    try {
      const content = await Deno.readTextFile(secretsPath);
      const secrets: Record<string, string> = {};

      for (const line of content.split("\n")) {
        const trimmed = line.trim();
        // Skip comments and empty lines
        if (!trimmed || trimmed.startsWith("#")) continue;

        const [key, ...valueParts] = trimmed.split("=");
        if (key && valueParts.length > 0) {
          secrets[key.trim()] = valueParts.join("=").trim();
        }
      }

      return secrets;
    } catch (error) {
      throw new Error(
        `Failed to load secrets: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  /**
   * Save a secret to the secrets file
   */
  static async saveSecret(
    key: string,
    value: string,
    scope: "user" | "project" = "project",
  ): Promise<void> {
    const secretsPath = scope === "user" ? this.getUserSecretsPath() : this.getSecretsPath();

    // Load existing secrets
    const secrets = await this.loadSecrets(scope);
    secrets[key] = value;

    // Write back to file
    const lines = [
      "# Generated by ftk - DO NOT COMMIT",
      "# MCP Server Secrets",
      "",
    ];

    for (const [k, v] of Object.entries(secrets)) {
      lines.push(`${k}=${v}`);
    }

    await Deno.writeTextFile(secretsPath, lines.join("\n") + "\n");
  }

  /**
   * Check if a secret exists
   */
  static async hasSecret(
    key: string,
    scope: "user" | "project" = "project",
  ): Promise<boolean> {
    const secrets = await this.loadSecrets(scope);
    return key in secrets;
  }

  /**
   * Get a specific secret
   */
  static async getSecret(
    key: string,
    scope: "user" | "project" = "project",
  ): Promise<string | undefined> {
    const secrets = await this.loadSecrets(scope);
    return secrets[key];
  }

  /**
   * Initialize secrets file if it doesn't exist
   */
  static async initSecretsFile(scope: "user" | "project" = "project"): Promise<void> {
    const secretsPath = scope === "user" ? this.getUserSecretsPath() : this.getSecretsPath();

    if (await exists(secretsPath)) {
      return;
    }

    const content = [
      "# Generated by ftk - DO NOT COMMIT",
      "# MCP Server Secrets",
      "",
      "# Add your API keys and secrets here:",
      "# EXA_API_KEY=your_key_here",
      "# FIRECRAWL_API_KEY=your_key_here",
      "",
    ].join("\n");

    await Deno.writeTextFile(secretsPath, content);
  }

  /**
   * Ensure .env.mcp.secrets is in .gitignore
   */
  static async ensureGitignore(): Promise<void> {
    const gitignorePath = join(Deno.cwd(), ".gitignore");
    const secretsEntry = ".env.mcp.secrets";

    let content = "";
    if (await exists(gitignorePath)) {
      content = await Deno.readTextFile(gitignorePath);
    }

    // Check if already exists
    if (content.includes(secretsEntry)) {
      return;
    }

    // Add to gitignore
    const lines = content.trim().split("\n");

    // Find or create environment section
    const envSectionIndex = lines.findIndex((line) => line.toLowerCase().includes("environment"));

    if (envSectionIndex >= 0) {
      // Add after environment section header
      lines.splice(envSectionIndex + 1, 0, secretsEntry);
    } else {
      // Add new section
      if (lines.length > 0 && lines[lines.length - 1] !== "") {
        lines.push("");
      }
      lines.push("# Environment variables and secrets");
      lines.push(secretsEntry);
    }

    await Deno.writeTextFile(gitignorePath, lines.join("\n") + "\n");
  }

  /**
   * Validate a secret (optional custom validation)
   */
  static validateSecret(
    _key: string,
    value: string,
    validateFn?: string,
  ): boolean {
    // Basic validation: non-empty
    if (!value || value.trim().length === 0) {
      return false;
    }

    // Custom validation function not implemented yet
    // Would require careful security review before executing user-provided code
    if (validateFn) {
      console.warn("Custom validation functions are not yet supported");
    }

    return true;
  }
}
